	Javamop improvement plan (2015 Jan)

Proofread the docs of javamopagent (Owolabi)
I wrote the usage doc for javamopagent sometime ago based on the current description of agent thing 
in javamop's usage doc. We want to keep all the desired features of the previous AgentGenerator, and
ensure the new javamopagent is as robust as the previous AgentGenerator in javamop.
 
Action: proofread the JavaMOPAgentUsage.md in `https://github.com/runtimeverification/javamop/blob/agent/docs/JavaMOPAgentUsage.md`,
and compare the behaviors of the agent generators of javamop's -agent option and javamopagent.


General testing (Yi)
We want our newly separated javamopagent tool bug-free.

Action: Try all the approaches to break the javamopagent and report the bugs.



Make naming conventions consistent accross javamop and rv-monitor (Qingzhou)

There exist some differences between the names of parameters in the monitor's methods
generated by javamop's -agent option and javamopagent. I'm not sure whether javamop 
does some further processing to the parameters' names or I missed some options when
executing rv-monitor. 

Action: Find out a configuration that makes the monitor classes generated 
by javamop's -agent option and rv-monitor have exactly the same variable names at the same place. 


Integration test (He)
I've removed the -baseaspect option in javamopagent and only keep it in javamop.
Furthermore, I inlined the default baseaspect in the generated .aj file if there is
no BaseAspect provided by the users.

As suggested by Qingzhou, we need to have an integration test to ensure the -baseaspect option
works fine. Specifically,

1) When user doesn't provide -baseaspect, we will generate that in the .aj
file
2) When user provides -baseaspect, we will use that file and the generated
.aj file will ignore those specific classes (by running the instrumented
code)

Action: Write integration tests for checking -baseaspect option.


Unit Tests (Ali)

Our javamop will be refactored a lot in the following weeks.
Before we do the major change, we need to be confident that 
the refactored project does not change its original behavior.

Therefore, we need to do some preparation for the refactoring now.
Ali, do you remember that we worked together to write some unit tests some time ago?
At that time, I built a preliminary testing infrastructure which includes the initial serialization files
generated by the original javamop (before refactoring). My initial plan was: each time we made some refactoring, 
we run the unit tests to generate the new serialization files; and then compare the new serialization files with the original ones, if they are exactly the same, then the internal structures of the outputs must be the same and our refactoring does not change the behavior of javamop. However, I found that there were many false alarms using that approach. I found that we may get different serialization files for the same AST if we use different java compilers. Therefore, it seems that the most reliable way of designing unit tests is comparing the AST, which requires the definitions of equals() method in the relevant node classes.

Action: Complete the unit test infrastructure and ensure it works in all the supported JDK (1.7 or above).


