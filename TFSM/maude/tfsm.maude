fmod TFSM is
protecting QID .
protecting NAT .
protecting BOOL .

sort Event .
subsort Qid < Event .

op timeout : -> Event [ctor] .

sort TEvent .
*** Timed event.

op _@_ : Event Nat -> TEvent [ctor] .

op event(_) : TEvent -> Event .
op time(_) : TEvent -> Nat .

************************************************

sorts State TState .

op _@_ : State Nat -> TState [ctor] .

op state(_) : TState -> State .
op time(_) : TState -> Nat .


************************************************

*** Time constraint function: given state and event, returns the associated time interval.

sort TInterval .

op (_,_) : Nat Nat -> TInterval [ctor] .

*** Need info of the rvm spec.
op I(_,_) : State Event -> TInterval .

op inBet(_,_) : Nat TInterval -> Bool .

op addBase(_,_) : Nat TInterval -> TInterval .

************************************************
***The normal transition function, need info of rvm spec to instantiate.
op transit(_,_) : State Event -> State .

***The timed transition function
op transit(_,_) : TState TEvent -> TState .

op D1(_,_,_,_) : State Nat Event Nat -> TState .

op D2(_,_,_,_,_) : State Nat Event Nat TInterval -> TState .

op err : -> TState .
************************************************************************
var S : State .
var E : Event .
vars T LB UB OldT EventT : Nat .
var TS : TState .
var TE : TEvent .
var TI : TInterval .


eq state(S @ T) = S .

eq time(S @ T) = T .

eq addBase(T, (LB,UB)) = (LB + T, UB + T) .
ceq inBet(T, (LB, UB)) = true if (T >= LB) /\ (T < UB) .
eq inBet(T,TI) = false [owise] .

eq transit(TS, TE) = D1(state(TS), time(TS), event(TE), time(TE)) .

eq D1(S, OldT, E, EventT) = D2(S, OldT, E, EventT, I(S, E)) .



ceq D2(S, OldT, E, EventT, TI) = (transit(S, E) @ EventT) if inBet(EventT, addBase(OldT, TI)) . 

eq D2(S, OldT, E, EventT, TI) = err [owise] .


endfm
