fmod TFSM is
protecting QID .
protecting NAT .
protecting BOOL .

sort Event .
subsort Qid < Event .

op timeout : -> Event [ctor] .

sort TEvent .
*** Timed event.

op _@_ : Event Nat -> TEvent [ctor] .

op event(_) : TEvent -> Event .
op time(_) : TEvent -> Nat .

sort Trace .
subsort TEvent < Trace .

op nil : -> Trace .
op _::_ : TEvent Trace -> Trace [id: nil ctor] .
************************************************

sorts State TState .

op err : -> State .

op _@_ : State Nat -> TState [ctor] .

op state(_) : TState -> State .
op time(_) : TState -> Nat .


************************************************

*** Time constraint function: given state and event, returns the associated time interval.

sort TInterval .

op (_,_) : Nat Nat -> TInterval [ctor] .

*** Need info of the rvm spec.
op I(_,_) : State Event -> TInterval .

op inBet(_,_) : Nat TInterval -> Bool .

op addBase(_,_) : Nat TInterval -> TInterval .

************************************************
***The normal transition function, need info of rvm spec to instantiate.
op transit(_,_) : State Event -> State .

***The timed transition function
op transit(_,_) : TState TEvent -> TState .

op D1(_,_,_,_) : State Nat Event Nat -> TState .

op D2(_,_,_,_,_) : State Nat Event Nat TInterval -> TState .

************************************************************************
op readTrace(_,_) : TState Trace -> TState .

sort FinalS . ***Need to be instantiated by the monitor.

subsort FinalS < TState .

op initS : -> TState .
op isFinal(_) : TState -> Bool .

op accept(_) : Trace -> Bool .

************************************************************************
var S : State .
var E : Event .
vars T LB UB OldT EventT : Nat .
var TS : TState .
var TE : TEvent .
var TI : TInterval .
var TR : Trace .

***getter methods

eq state(S @ T) = S .

eq time(S @ T) = T .

***util functions

eq addBase(T, (LB,UB)) = (LB + T, UB + T) .
ceq inBet(T, (LB, UB)) = true if (T >= LB) /\ (T < UB) .
eq inBet(T,TI) = false [owise] .

***Transition function's implementation

eq transit(TS, TE) = D1(state(TS), time(TS), event(TE), time(TE)) .

eq D1(S, OldT, E, EventT) = D2(S, OldT, E, EventT, I(S, E)) .

***Events happened in the right time interval.
ceq D2(S, OldT, E, EventT, TI) = (transit(S, E) @ EventT) if inBet(EventT, addBase(OldT, TI)) . 


***readTrace's implementation.

eq readTrace(TS, nil) = TS .

eq readTrace(TS, TE) = transit(TS, TE) .

eq readTrace(TS, TE :: TR) = readTrace(transit(TS, TE), TR) .


***Decision procedure

eq accept(TR) = isFinal(readTrace(initS, TR)) .



endfm
